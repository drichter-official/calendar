<!DOCTYPE html>
<html>
<head>
    <title>{{ _('Door') }} {{door}} - {{ _('Interactive Sudoku') }}</title>
    <style>
        /* Language switcher styles */
        .language-switcher {
            position: fixed;
            top: 15px;
            right: 15px;
            z-index: 1000;
        }
        
        .language-dropdown {
            position: relative;
            display: inline-block;
        }
        
        .language-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
        }
        
        .language-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }
        
        .language-btn:active {
            transform: translateY(0);
        }
        
        .language-icon {
            font-size: 18px;
        }
        
        .dropdown-arrow {
            font-size: 12px;
            transition: transform 0.3s ease;
        }
        
        .language-dropdown.active .dropdown-arrow {
            transform: rotate(180deg);
        }
        
        .language-menu {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            min-width: 150px;
        }
        
        .language-dropdown.active .language-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        
        .language-option {
            padding: 12px 20px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #333;
            text-decoration: none;
            font-family: Arial, system-ui, sans-serif;
            font-size: 10px;
            font-weight: 500;

        }
        
        .language-option:hover {
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
        }
        
        .language-option.active {
            background: linear-gradient(135deg, #667eea25 0%, #764ba225 100%);
            color: #667eea;
        }
        
        .flag-icon {
            font-size: 15px;
        }
        
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f0f0;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .sudoku-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
            position: relative;
        }
        .sudoku {
            border-collapse: separate;
            border-spacing: 0;
            background-color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border: 3px solid #000000 !important;        /* Thick outer border */
        }
        .diagonal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1;
        }
        .sudoku td {
            width: 50px;
            height: 50px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            position: relative;
            box-sizing: border-box;
            border-top: 1px solid #bbb;        /* Thin default grid line */
            border-left: 1px solid #bbb;
            border-right: 0;
            border-bottom: 0;
        }
        /* Apply cream background to cells with inputs (editable cells) */
        .sudoku td:has(input) {
            background-color: #fffef0;
        }
        /* Remove top border for first row (leave for table) */
        .sudoku tr:first-child td {
            border-top: none;
        }
        /* Remove left border for first column (leave for table) */
        .sudoku td:first-child {
            border-left: none;
        }
        /* Thick top borders after rows 3 and 6 (for box separators) */
        .sudoku tr:nth-child(4) td,
        .sudoku tr:nth-child(7) td {
            border-top: 2px solid #000;
        }
        /* Thick left borders after columns 3 and 6 (for box separators) */
        .sudoku td:nth-child(4),
        .sudoku td:nth-child(7) {
            border-left: 2px solid #000;
        }
        /* When standard boxes are not used, remove the thick 3x3 box separator lines */
        .sudoku.no-box-borders tr:nth-child(4) td,
        .sudoku.no-box-borders tr:nth-child(7) td {
            border-top: 1px solid #bbb;
        }
        .sudoku.no-box-borders td:nth-child(4),
        .sudoku.no-box-borders td:nth-child(7) {
            border-left: 1px solid #bbb;
        }
        /* No bottom border for last row (table border only) */
        .sudoku tr:last-child td {
            border-bottom: none;
        }
        /* No right border for last column (table border only) */
        .sudoku td:last-child {
            border-right: none;
        }
        .sudoku td input {
            width: 100%;
            height: 100%;
            border: none;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            outline: none;
            background-color: transparent;
        }
        .sudoku td .notes {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 0.7rem;
            font-weight: normal;
            color: #666;
            line-height: 1.1;
            pointer-events: none;
            max-width: 40px;
            word-wrap: break-word;
        }

        /* Remove browser focus outline/shadow and hide the blinking caret when an input is focused
           This removes the blue blinking line on focused inputs while preserving the selected-cell
           outline which is applied to the parent <td>. */
        .sudoku td input:focus {
            outline: none !important;
            box-shadow: none !important;
            -webkit-box-shadow: none !important;
            -webkit-appearance: none !important;
            caret-color: transparent !important; /* hides blinking caret */
            -webkit-tap-highlight-color: transparent !important; /* mobile tap highlight */
        }

        /* Layer 1: Base background - LOWEST PRIORITY */
        /* Default input background is set above */

        /* Layer 2: Prefilled cells - overrides background, borders show through */
        .sudoku td.prefilled {
            background-color: #e8e8e8;
            color: inherit;
            cursor: pointer;
        }
        .sudoku td.prefilled:focus {
            outline: none; /* Remove default outline, we use selected-cell class */
        }

        /* Layer 3: Special field colors - override prefilled cells, borders show through */
        .sudoku td.diagonal-cell {
            background-color: #e8f4f8 !important;
            color: inherit;
        }
        .sudoku td.windoku-cell {
            background-color: #e3f2fd !important;
            color: inherit;
        }
        .sudoku td.asterisk-cell {
            background-color: #fff9c4 !important;
            color: inherit;
        }
        .sudoku td.even-cell {
            background-color: #c8e6c9 !important;
            color: inherit;
        }
        .sudoku td.odd-cell {
            background-color: #ffccbc !important;
            color: inherit;
        }
        .sudoku td.magic-square-cell {
            background-color: #c8efca !important;
            color: inherit;
        }
        .sudoku td.center-dot-cell {
            background-color: #ffe0b2 !important;
            color: inherit;
        }
        .sudoku td.thermo-cell {
            background-color: #e1f5fe !important;
            color: inherit;
        }
        .sudoku td.arrow-circle {
            background-color: #c0c0c0 !important;
            color: inherit;
        }
        .sudoku td.arrow-cell {
            background-color: #fffde7 !important;
            color: inherit;
        }
        .sudoku td.renban-cell {
            background-color: #f3e5f5 !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-0 {
            background-color: #ffebee !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-1 {
            background-color: #e8f5e9 !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-2 {
            background-color: #e3f2fd !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-3 {
            background-color: #fff3e0 !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-4 {
            background-color: #f3e5f5 !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-5 {
            background-color: #fce4ec !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-6 {
            background-color: #e0f2f1 !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-7 {
            background-color: #fff9c4 !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-8 {
            background-color: #e1f5fe !important;
            color: inherit;
        }
        .sudoku td.whisper-cell {
            background-color: #e1bee7 !important;
            color: inherit;
        }
        .sudoku td.whisper-line-0 {
            background-color: #ce93d8 !important;
            color: inherit;
        }
        .sudoku td.whisper-line-1 {
            background-color: #b3e5fc !important;
            color: inherit;
        }
        .sudoku td.whisper-line-2 {
            background-color: #c8e6c9 !important;
            color: inherit;
        }
        .sudoku td.whisper-line-3 {
            background-color: #ffccbc !important;
            color: inherit;
        }
        .sudoku td.whisper-line-4 {
            background-color: #fff9c4 !important;
            color: inherit;
        }
        .sudoku td.whisper-line-5 {
            background-color: #d1c4e9 !important;
            color: inherit;
        }
        .sudoku td.whisper-line-6 {
            background-color: #f8bbd0 !important;
            color: inherit;
        }
        .sudoku td.whisper-line-7 {
            background-color: #ffe0b2 !important;
            color: inherit;
        }
        .sudoku td.chain-corner-cell {
            background-color: #ffecb3 !important;
            color: inherit;
        }
        .sudoku td.consecutive-line-0 {
            background-color: #c5e1a5 !important;
            color: inherit;
        }
        .sudoku td.consecutive-line-1 {
            background-color: #b3e5fc !important;
            color: inherit;
        }
        .sudoku td.consecutive-line-2 {
            background-color: #ffe0b2 !important;
            color: inherit;
        }
        .sudoku td.consecutive-line-3 {
            background-color: #f8bbd0 !important;
            color: inherit;
        }
        .sudoku td.consecutive-line-4 {
            background-color: #d1c4e9 !important;
            color: inherit;
        }
        .sudoku td.consecutive-line-5 {
            background-color: #ffccbc !important;
            color: inherit;
        }
        .sudoku td.consecutive-line-6 {
            background-color: #c8e6c9 !important;
            color: inherit;
        }
        .sudoku td.consecutive-line-7 {
            background-color: #fff9c4 !important;
            color: inherit;
        }
        /*.sudoku td.argyle-cell {
            background-color: #d1c4e9 !important;
            color: inherit;
        }*/
        .sudoku td.star-cell {
            background-color: #fff59d !important;
            color: inherit;
        }
        /* Killer cage styles removed - now using SVG overlay for proper dashed borders */

        /* Make all special field inputs transparent so background shows through */
        .sudoku td.diagonal-cell input,
        .sudoku td.windoku-cell input,
        .sudoku td.asterisk-cell input,
        .sudoku td.even-cell input,
        .sudoku td.odd-cell input,
        .sudoku td.magic-square-cell input,
        .sudoku td.center-dot-cell input,
        .sudoku td.thermo-cell input,
        .sudoku td.arrow-circle input,
        .sudoku td.arrow-cell input,
        .sudoku td.renban-cell input,
        .sudoku td.whisper-cell input,
        .sudoku td.whisper-line-0 input,
        .sudoku td.whisper-line-1 input,
        .sudoku td.whisper-line-2 input,
        .sudoku td.whisper-line-3 input,
        .sudoku td.whisper-line-4 input,
        .sudoku td.whisper-line-5 input,
        .sudoku td.whisper-line-6 input,
        .sudoku td.whisper-line-7 input,
        .sudoku td.chain-corner-cell input,
        .sudoku td.consecutive-line-0 input,
        .sudoku td.consecutive-line-1 input,
        .sudoku td.consecutive-line-2 input,
        .sudoku td.consecutive-line-3 input,
        .sudoku td.consecutive-line-4 input,
        .sudoku td.consecutive-line-5 input,
        .sudoku td.consecutive-line-6 input,
        .sudoku td.consecutive-line-7 input,
        .sudoku td.star-cell input,
        .sudoku td.jigsaw-region-0 input,
        .sudoku td.jigsaw-region-1 input,
        .sudoku td.jigsaw-region-2 input,
        .sudoku td.jigsaw-region-3 input,
        .sudoku td.jigsaw-region-4 input,
        .sudoku td.jigsaw-region-5 input,
        .sudoku td.jigsaw-region-6 input,
        .sudoku td.jigsaw-region-7 input,
        .sudoku td.jigsaw-region-8 input,
        .sudoku td.jigsaw-region-9 input

        {
            background-color: transparent;
        }
        /* Layer 4: Interactive highlights - override special field colors */
        .sudoku td.rowcol-highlight {
            background-color: #f3e5f5 !important; /* very light blue for row/col */
            color: inherit;
        }
        .sudoku td.highlighted-user {
            background-color: #ce93d8 !important; /* purple for user-filled same number */
            color: inherit;
        }
        .sudoku td.highlighted-prefilled {
            background-color: #b995f0 !important; /* darker purple for prefilled same number */
            color: inherit;
        }
        .sudoku td.rowcol-highlight input,
        .sudoku td.highlighted-user input,
        .sudoku td.highlighted-prefilled input {
            background-color: transparent;
        }

        /* Selected cell outline - doesn't change background */
        .sudoku td.selected-cell {
            outline: 2px solid #b995f0;
            outline-offset: -2px;
            z-index: 10;
            position: relative;
        }

        /* Layer 5: Validation colors - HIGHEST PRIORITY - override everything */
        .sudoku td.correct {
            background-color: #a5d6a7 !important;
            color: inherit;
        }
        .sudoku td.correct input {
            background-color: transparent;
        }
        .sudoku td.incorrect {
            background-color: #ef9a9a !important;
            color: inherit;
        }
        .sudoku td.incorrect input {
            background-color: transparent;
        }
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        button {
            padding: 10px 20px;
            font-size: 1rem;
            margin: 5px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        button.secondary {
            background-color: #2196F3;
        }
        button.secondary:hover {
            background-color: #0b7dda;
        }
        button.notes-toggle {
            background-color: #673AB7;
            font-weight: bold;
            position: relative;
        }
        button.notes-toggle:hover {
            background-color: #5E35B1;
        }
        button.notes-toggle.active {
            background-color: #FF9800;
            box-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
        }
        button.notes-toggle.active:hover {
            background-color: #F57C00;
        }
        button.notes-toggle .hotkey {
            font-size: 0.75rem;
            opacity: 0.8;
            margin-left: 5px;
        }
        button.hint-btn {
            background-color: #FFC107;
            font-weight: bold;
            position: relative;
        }
        button.hint-btn:hover {
            background-color: #FFB300;
        }
        button.hint-btn.active {
            background-color: #FF9800;
            box-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
        }
        button.hint-btn.active:hover {
            background-color: #F57C00;
        }
        button.hint-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        button.hint-btn .hint-count {
            display: inline-block;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            line-height: 20px;
            text-align: center;
            margin-left: 8px;
            font-size: 0.85rem;
        }
        /* Hint cell styling - light yellow background */
        .sudoku td.hint-cell {
            background-color: #fff9c4 !important;
            color: inherit;
        }
        .sudoku td.hint-cell input {
            background-color: transparent;
            color: #333;
        }
        #message {
            text-align: center;
            margin: 20px 0;
            padding: 10px;
            font-size: 1.1rem;
            font-weight: bold;
        }
        .success {
            color: #4CAF50;
        }
        .error {
            color: #f44336;
        }
        .back-link {
            display: block;
            text-align: center;
            margin: 20px 0;
            text-decoration: none;
            color: #2196F3;
            font-size: 1rem;
        }
        .back-link:hover {
            text-decoration: underline;
        }
        .sudoku-wrapper {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            position: relative;
        }
        .highlight-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 15px 18px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            min-width: 180px;
            z-index: 1000;
        }
        .highlight-controls h3 {
            margin: 0 0 8px 0;
            font-size: 0.95rem;
            color: #333;
            font-weight: 600;
        }
        .checkbox-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px;
            border-radius: 5px;
            transition: background-color 0.2s;
        }
        .checkbox-option:hover {
            background-color: #f5f5f5;
        }
        .checkbox-option input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #9c27b0;
        }
        .checkbox-option label {
            cursor: pointer;
            font-size: 0.9rem;
            color: #444;
            user-select: none;
        }
    </style>
</head>
<body>
    <!-- Language Switcher -->
    <div class="language-switcher">
        <div class="language-dropdown" id="languageDropdown">
            <button class="language-btn" onclick="toggleLanguageMenu()">
                <span class="language-icon">üåê</span>
                <span id="currentLanguage">{{ get_locale().upper() }}</span>
                <span class="dropdown-arrow">‚ñº</span>
            </button>
            <div class="language-menu">
                <div class="language-option {% if get_locale() == 'de' %}active{% endif %}" onclick="changeLanguage('de')">
                    <span class="flag-icon">üá©üá™</span>
                    <span>Deutsch</span>
                </div>
                <div class="language-option {% if get_locale() == 'en' %}active{% endif %}" onclick="changeLanguage('en')">
                    <span class="flag-icon">üá¨üáß</span>
                    <span>English</span>
                </div>
            </div>
        </div>
    </div>
    
    <h1>{{ _('Day') }} {{ door }} - {{ rule_name }}</h1>
    <p style="text-align: center;">{{ rule_description }}</p>

    <div class="sudoku-container">
        <div class="sudoku-wrapper">
            <div style="position: relative;">
                <svg class="diagonal-overlay" id="diagonalOverlay"></svg>
                <table class="sudoku{% if metadata.rule.use_standard_boxes == false %} no-box-borders{% endif %}" id="sudokuGrid">
            {% for i in range(9) %}
            <tr>
                {% for j in range(9) %}
                <td class="{{ 'prefilled' if sudoku[i][j] != 0 else '' }}" data-row="{{i}}" data-col="{{j}}" {% if sudoku[i][j] != 0 %}tabindex="0"{% endif %}>
                    {% if sudoku[i][j] != 0 %}
                        {{ sudoku[i][j] }}
                    {% else %}
                        <div class="notes" data-row="{{i}}" data-col="{{j}}"></div>
                        <input type="text" maxlength="1" data-row="{{i}}" data-col="{{j}}" />
                    {% endif %}
                </td>
                {% endfor %}
            </tr>
            {% endfor %}
        </table>
            </div>
        </div>
    </div>

    <!-- Fixed position highlight controls at bottom right -->
    <div class="highlight-controls">
        <h3>{{ _('Highlights') }}</h3>
        <div class="checkbox-option">
            <input type="checkbox" id="toggleRowCol" checked>
            <label for="toggleRowCol">{{ _('Row/Column') }}</label>
        </div>
        <div class="checkbox-option">
            <input type="checkbox" id="toggleSameNumber" checked>
            <label for="toggleSameNumber">{{ _('Same Number') }}</label>
        </div>
    </div>

    <div class="controls">
        <button id="notesToggle" onclick="toggleNotesMode()" class="notes-toggle">
            üìù {{ _('Notes Mode') }} <span class="hotkey">(Space)</span>
        </button>
        <button id="hintBtn" onclick="toggleHintMode()" class="hint-btn">
            üí° {{ _('Hint') }} <span class="hint-count" id="hintCount">3</span>
        </button>
        <br>
        <button onclick="checkSolution()">{{ _('Check Solution') }}</button>
        <button onclick="undo()" class="secondary">‚Ü∂ {{ _('Undo') }}</button>
        <button onclick="resetBoard()" class="secondary">{{ _('Reset') }}</button>
        <button onclick="generateNewPuzzle()" class="secondary">{{ _('Generate New Puzzle') }}</button>
    </div>

    <div id="message"></div>
    <div id="generation-message" style="text-align: center; margin: 10px 0; padding: 10px; font-size: 1rem;"></div>

    <a href="/" class="back-link">‚Üê {{ _('Back to Calendar') }}</a>

    <script>
        // Store the solution and metadata
        const solution = {{ solution | tojson }};
        const initialPuzzle = {{ sudoku | tojson }};
        const metadata = {{ metadata | tojson }};

        // Translated strings for Notes Mode button
        const notesModeText = "{{ _('Notes Mode') }}";
        const notesModeOnText = "{{ _('ON') }}";
        const notesModeOffHTML = 'üìù ' + notesModeText + ' <span class="hotkey">(Space)</span>';
        const notesModeOnHTML = 'üìù ' + notesModeText + ' <span class="hotkey">(Space)</span> - ' + notesModeOnText;

        // Highlight settings (default enabled)
        let highlightRowColEnabled = true;
        let highlightSameNumberEnabled = true;

        // Notes mode (default disabled)
        let notesMode = false;
        const cellNotes = {}; // Store notes for each cell: {row,col: Set of numbers}

        // Hint mode (default disabled)
        let hintMode = false;
        let hintsRemaining = 3;
        const hintModeText = "{{ _('Hint') }}";
        const hintModeOnText = "{{ _('Select a cell') }}";

        // Undo system - track all user actions
        const undoHistory = [];
        const MAX_UNDO_STEPS = 100; // Limit history to prevent memory issues

        function recordAction(action) {
            undoHistory.push(action);
            // Limit history size
            if (undoHistory.length > MAX_UNDO_STEPS) {
                undoHistory.shift();
            }
        }

        function undo() {
            if (undoHistory.length === 0) {
                const messageDiv = document.getElementById('message');
                messageDiv.innerHTML = '<span style="color: #ff9800;">Nothing to undo</span>';
                setTimeout(() => { messageDiv.innerHTML = ''; }, 2000);
                return;
            }

            const action = undoHistory.pop();

            if (action.type === 'number') {
                // Undo number entry
                const input = document.querySelector(`input[data-row="${action.row}"][data-col="${action.col}"]`);
                if (input) {
                    input.value = action.oldValue;
                    const cell = input.parentElement;
                    cell.classList.remove('correct', 'incorrect');
                }
            } else if (action.type === 'note') {
                // Undo note action
                const key = `${action.row},${action.col}`;
                if (action.operation === 'add') {
                    // Remove the note that was added
                    if (cellNotes[key]) {
                        cellNotes[key].delete(action.value);
                        if (cellNotes[key].size === 0) {
                            delete cellNotes[key];
                        }
                    }
                } else if (action.operation === 'remove') {
                    // Re-add the note that was removed
                    if (!cellNotes[key]) {
                        cellNotes[key] = new Set();
                    }
                    cellNotes[key].add(action.value);
                } else if (action.operation === 'clear') {
                    // Restore the notes that were cleared
                    cellNotes[key] = new Set(action.oldNotes);
                }
                updateNotesDisplay(action.row, action.col);
            }
        }

        // Toggle notes mode function
        function toggleNotesMode() {
            notesMode = !notesMode;
            const btn = document.getElementById('notesToggle');
            if (notesMode) {
                btn.classList.add('active');
                btn.innerHTML = notesModeOnHTML;
                // Disable hint mode when enabling notes mode
                if (hintMode) {
                    disableHintMode();
                }
            } else {
                btn.classList.remove('active');
                btn.innerHTML = notesModeOffHTML;
            }
        }

        // Toggle hint mode function
        function toggleHintMode() {
            if (hintsRemaining <= 0) {
                return;
            }
            hintMode = !hintMode;
            const btn = document.getElementById('hintBtn');
            const messageDiv = document.getElementById('message');
            if (hintMode) {
                btn.classList.add('active');
                updateHintButtonDisplay();
                messageDiv.innerHTML = '<span style="color: #FFC107;">{{ _("Click on an empty cell to reveal its correct number") }}</span>';
                // Disable notes mode when enabling hint mode
                if (notesMode) {
                    notesMode = false;
                    const notesBtn = document.getElementById('notesToggle');
                    notesBtn.classList.remove('active');
                    notesBtn.innerHTML = notesModeOffHTML;
                }
            } else {
                disableHintMode();
            }
        }

        // Disable hint mode helper
        function disableHintMode() {
            hintMode = false;
            const btn = document.getElementById('hintBtn');
            btn.classList.remove('active');
            updateHintButtonDisplay();
            document.getElementById('message').innerHTML = '';
        }

        // Update the hint button display (centralized function)
        function updateHintButtonDisplay() {
            const btn = document.getElementById('hintBtn');
            if (hintsRemaining <= 0) {
                btn.disabled = true;
                btn.innerHTML = 'üí° ' + hintModeText + ' <span class="hint-count" id="hintCount">0</span>';
            } else {
                btn.disabled = false;
                if (hintMode) {
                    btn.innerHTML = 'üí° ' + hintModeOnText + ' <span class="hint-count" id="hintCount">' + hintsRemaining + '</span>';
                } else {
                    btn.innerHTML = 'üí° ' + hintModeText + ' <span class="hint-count" id="hintCount">' + hintsRemaining + '</span>';
                }
            }
        }

        // Apply hint to a cell
        function applyHint(row, col) {
            if (!hintMode || hintsRemaining <= 0) return false;
            
            // Get the input element for this cell
            const input = document.querySelector(`input[data-row="${row}"][data-col="${col}"]`);
            if (!input) return false; // Prefilled cell
            
            // Get the correct value from the solution
            const correctValue = solution[row][col];
            
            // Fill in the correct value (hints are not undoable)
            input.value = correctValue;
            input.setAttribute('data-old-value', String(correctValue));
            
            // Add hint cell styling (light yellow)
            const cell = input.parentElement;
            cell.classList.add('hint-cell');
            cell.classList.remove('correct', 'incorrect');
            
            // Clear any notes for this cell
            const key = `${row},${col}`;
            if (cellNotes[key]) {
                delete cellNotes[key];
                updateNotesDisplay(row, col);
            }
            
            // Decrement hints remaining and update display
            hintsRemaining--;
            disableHintMode();
            
            return true;
        }

        // Add global spacebar listener
        document.addEventListener('keydown', function(e) {
            if (e.code === 'Space' && e.target.tagName !== 'INPUT') {
                e.preventDefault();
                toggleNotesMode();
            }
        });

        // Add event listeners for checkboxes
        document.addEventListener('DOMContentLoaded', function() {
            const rowColCheckbox = document.getElementById('toggleRowCol');
            const sameNumberCheckbox = document.getElementById('toggleSameNumber');

            rowColCheckbox.addEventListener('change', function() {
                highlightRowColEnabled = this.checked;
                // Refresh highlights if a cell is currently selected
                const selectedInput = document.querySelector('.sudoku input:focus');
                const selectedPrefilled = document.querySelector('.sudoku td.prefilled:focus');
                if (selectedInput) {
                    highlightSameNumbersAndRowCol(selectedInput, selectedInput.value);
                } else if (selectedPrefilled) {
                    highlightSameNumbersAndRowCol(selectedPrefilled, selectedPrefilled.textContent.trim());
                }
            });

            sameNumberCheckbox.addEventListener('change', function() {
                highlightSameNumberEnabled = this.checked;
                // Refresh highlights if a cell is currently selected
                const selectedInput = document.querySelector('.sudoku input:focus');
                const selectedPrefilled = document.querySelector('.sudoku td.prefilled:focus');
                if (selectedInput) {
                    highlightSameNumbersAndRowCol(selectedInput, selectedInput.value);
                } else if (selectedPrefilled) {
                    highlightSameNumbersAndRowCol(selectedPrefilled, selectedPrefilled.textContent.trim());
                }
            });

            applySpecialCellHighlighting();
            drawArgyleDiagonals();
            drawXVMarkers();
            drawKropkiDots();
            drawArrows();
            drawKillerCages();
            drawFutoshikiInequalities();
        });

        function applySpecialCellHighlighting() {
            const rule = metadata.rule;

            // Diagonal cells (Diagonal Rule)
            if (rule.diagonal_cells) {
                rule.diagonal_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('diagonal-cell');
                });
            } else if (rule.name && rule.name.includes('Diagonal')) {
                // Fallback for old metadata without diagonal_cells
                for (let i = 0; i < 9; i++) {
                    // Main diagonal
                    const cell1 = document.querySelector(`td[data-row="${i}"][data-col="${i}"]`);
                    if (cell1) cell1.classList.add('diagonal-cell');

                    // Anti-diagonal
                    const cell2 = document.querySelector(`td[data-row="${i}"][data-col="${8-i}"]`);
                    if (cell2) cell2.classList.add('diagonal-cell');
                }
            }

            // Windoku regions
            if (rule.windoku_regions) {
                rule.windoku_regions.forEach(region => {
                    region.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('windoku-cell');
                    });
                });
            }

            // Asterisk cells
            if (rule.asterisk_cells) {
                rule.asterisk_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('asterisk-cell');
                });
            }

            // Even cells
            if (rule.even_cells) {
                rule.even_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('even-cell');
                });
            }

            // Odd cells
            if (rule.odd_cells) {
                rule.odd_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('odd-cell');
                });
            }

            // Magic Square cells
            if (rule.magic_box_location) {
                const loc = rule.magic_box_location;
                loc.rows.forEach(row => {
                    loc.cols.forEach(col => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('magic-square-cell');
                    });
                });
            }

            // Center Dot cells (center of each 3x3 box)
            if (rule.center_dot_cells) {
                rule.center_dot_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('center-dot-cell');
                });
            } else if (rule.name && rule.name.includes('Center Dot')) {
                // Fallback for old metadata without center_dot_cells
                for (let boxRow = 0; boxRow < 3; boxRow++) {
                    for (let boxCol = 0; boxCol < 3; boxCol++) {
                        const centerRow = boxRow * 3 + 1;
                        const centerCol = boxCol * 3 + 1;
                        const cell = document.querySelector(`td[data-row="${centerRow}"][data-col="${centerCol}"]`);
                        if (cell) cell.classList.add('center-dot-cell');
                    }
                }
            }

            // Killer Sudoku cages - now handled by drawKillerCages() using SVG overlay

            // Thermometer cells
            if (rule.thermometers) {
                rule.thermometers.forEach(thermo => {
                    thermo.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('thermo-cell');
                    });
                });
            }

            // Arrow Sudoku
            if (rule.arrows) {
                rule.arrows.forEach(arrow => {
                    // Circle cell
                    const [circleRow, circleCol] = arrow.circle;
                    const circleCell = document.querySelector(`td[data-row="${circleRow}"][data-col="${circleCol}"]`);
                    if (circleCell) circleCell.classList.add('arrow-circle');

                    // Arrow cells
                    arrow.arrow_cells.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('arrow-cell');
                    });
                });
            }

            // Renban lines
            if (rule.renban_lines) {
                rule.renban_lines.forEach(line => {
                    line.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('renban-cell');
                    });
                });
            }

            // Jigsaw regions
            if (rule.jigsaw_regions) {
                rule.jigsaw_regions.forEach((region, regionIndex) => {
                    region.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add(`jigsaw-region-${regionIndex}`);
                    });
                });
            }

            // Whisper lines - each line gets a different color
            if (rule.whisper_lines) {
                rule.whisper_lines.forEach((line, lineIndex) => {
                    line.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add(`whisper-line-${lineIndex % 8}`);
                    });
                });
            }

            // Chain Sudoku corner cells
            if (rule.corner_cells) {
                rule.corner_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('chain-corner-cell');
                });
            }

            // Consecutive lines
            if (rule.consecutive_lines) {
                rule.consecutive_lines.forEach((line, lineIndex) => {
                    line.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add(`consecutive-line-${lineIndex % 8}`);
                    });
                });
            }

            // Argyle cells (diagonals within boxes)
            if (rule.argyle_cells) {
                rule.argyle_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('argyle-cell');
                });
            }

            // Star pattern cells
            if (rule.star_cells) {
                rule.star_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('star-cell');
                });
            }

            // XV pairs - markers are drawn via SVG in drawXVMarkers()

            // Futoshiki inequalities - symbols are drawn via SVG in drawFutoshikiInequalities()

            // Kropki dots - drawn via SVG in drawKropkiDots()
        }

        // Helper function to get cell center coordinates (shared by overlay drawing functions)
        function getCellCenter(row, col, cellSize, borderWidth) {
            // Account for different border widths
            let x = borderWidth + col * cellSize;
            let y = borderWidth + row * cellSize;

            // Add thicker borders after columns 3 and 6
            if (col >= 3) x += 1;
            if (col >= 6) x += 1;

            // Add thicker borders after rows 3 and 6
            if (row >= 3) y += 1;
            if (row >= 6) y += 1;

            // Add half cell size to get center
            x += cellSize / 2;
            y += cellSize / 2;

            return { x, y };
        }

        // Draw argyle diagonal lines
        function drawArgyleDiagonals() {
            const rule = metadata.rule;
            if (!rule.argyle_diagonals) return;

            const svg = document.getElementById('diagonalOverlay');
            const table = document.getElementById('sudokuGrid');

            // Get table dimensions
            const tableRect = table.getBoundingClientRect();
            const containerRect = table.parentElement.getBoundingClientRect();

            // Set SVG dimensions to match table
            svg.setAttribute('width', tableRect.width);
            svg.setAttribute('height', tableRect.height);
            svg.style.width = tableRect.width + 'px';
            svg.style.height = tableRect.height + 'px';
            svg.style.left = (tableRect.left - containerRect.left) + 'px';
            svg.style.top = (tableRect.top - containerRect.top) + 'px';

            const cellSize = 50; // Cell size from CSS
            const borderWidth = 3; // Table border width

            // Color palette for different diagonals
            const colors = ['#FF4F4F7C', '#FF4F4F7C', '#FF4F4F7C', '#FF4F4F7C'];

            // Draw each diagonal
            rule.argyle_diagonals.forEach((diagonal, index) => {
                const color = colors[index % colors.length];

                // Create a path for this diagonal
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                // Build path data
                let pathData = '';
                diagonal.forEach((cell, cellIndex) => {
                    const [row, col] = cell;
                    const center = getCellCenter(row, col, cellSize, borderWidth);

                    if (cellIndex === 0) {
                        pathData += `M ${center.x} ${center.y}`;
                    } else {
                        pathData += ` L ${center.x} ${center.y}`;
                    }
                });

                path.setAttribute('d', pathData);
                path.setAttribute('stroke', color);
                path.setAttribute('stroke-width', '3');
                path.setAttribute('stroke-opacity', '0.6');
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');

                svg.appendChild(path);
            });
        }

        // Draw XV markers (small white boxes with X or V text between cells)
        function drawXVMarkers() {
            const rule = metadata.rule;
            if (!rule.x_pairs && !rule.v_pairs) return;

            const svg = document.getElementById('diagonalOverlay');
            const table = document.getElementById('sudokuGrid');

            // Get table dimensions
            const tableRect = table.getBoundingClientRect();
            const containerRect = table.parentElement.getBoundingClientRect();

            // Set SVG dimensions to match table
            svg.setAttribute('width', tableRect.width);
            svg.setAttribute('height', tableRect.height);
            svg.style.width = tableRect.width + 'px';
            svg.style.height = tableRect.height + 'px';
            svg.style.left = (tableRect.left - containerRect.left) + 'px';
            svg.style.top = (tableRect.top - containerRect.top) + 'px';

            const cellSize = 50; // Cell size from CSS
            const borderWidth = 3; // Table border width
            const markerSize = 18; // Size of the white box

            // Helper function to draw a marker between two cells
            function drawMarker(pair, text) {
                const [r1, c1] = pair[0];
                const [r2, c2] = pair[1];
                const center1 = getCellCenter(r1, c1, cellSize, borderWidth);
                const center2 = getCellCenter(r2, c2, cellSize, borderWidth);

                // Calculate midpoint between the two cells
                const midX = (center1.x + center2.x) / 2;
                const midY = (center1.y + center2.y) / 2;

                // Create a group for the marker
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');

                // Create the white box background
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', midX - markerSize / 2);
                rect.setAttribute('y', midY - markerSize / 2);
                rect.setAttribute('width', markerSize);
                rect.setAttribute('height', markerSize);
                rect.setAttribute('rx', '3');
                rect.setAttribute('ry', '3');
                rect.setAttribute('fill', 'white');
                rect.setAttribute('stroke', '#333');
                rect.setAttribute('stroke-width', '1');
                g.appendChild(rect);

                // Create the text (X or V)
                const textEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                textEl.setAttribute('x', midX);
                textEl.setAttribute('y', midY);
                textEl.setAttribute('text-anchor', 'middle');
                textEl.setAttribute('dominant-baseline', 'central');
                textEl.setAttribute('font-size', '12');
                textEl.setAttribute('font-weight', 'bold');
                textEl.setAttribute('font-family', 'Arial, sans-serif');
                textEl.setAttribute('fill', '#333');
                textEl.textContent = text;
                g.appendChild(textEl);

                svg.appendChild(g);
            }

            // Draw X markers
            if (rule.x_pairs) {
                rule.x_pairs.forEach(pair => {
                    drawMarker(pair, 'X');
                });
            }

            // Draw V markers
            if (rule.v_pairs) {
                rule.v_pairs.forEach(pair => {
                    drawMarker(pair, 'V');
                });
            }
        }

        // Draw Kropki dots (white circles for consecutive, black circles for ratio)
        function drawKropkiDots() {
            const rule = metadata.rule;
            if (!rule.white_dots && !rule.black_dots) return;

            const svg = document.getElementById('diagonalOverlay');
            const table = document.getElementById('sudokuGrid');

            // Get table dimensions
            const tableRect = table.getBoundingClientRect();
            const containerRect = table.parentElement.getBoundingClientRect();

            // Set SVG dimensions to match table
            svg.setAttribute('width', tableRect.width);
            svg.setAttribute('height', tableRect.height);
            svg.style.width = tableRect.width + 'px';
            svg.style.height = tableRect.height + 'px';
            svg.style.left = (tableRect.left - containerRect.left) + 'px';
            svg.style.top = (tableRect.top - containerRect.top) + 'px';

            const cellSize = 50; // Cell size from CSS
            const borderWidth = 3; // Table border width
            const dotRadius = 8; // Radius of the dot

            // Helper function to draw a dot between two cells
            function drawDot(pair, isWhite) {
                const [r1, c1] = pair[0];
                const [r2, c2] = pair[1];
                const center1 = getCellCenter(r1, c1, cellSize, borderWidth);
                const center2 = getCellCenter(r2, c2, cellSize, borderWidth);

                // Calculate midpoint between the two cells
                const midX = (center1.x + center2.x) / 2;
                const midY = (center1.y + center2.y) / 2;

                // Create the dot circle
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', midX);
                circle.setAttribute('cy', midY);
                circle.setAttribute('r', dotRadius);
                
                if (isWhite) {
                    // White dot (consecutive - differ by 1)
                    circle.setAttribute('fill', 'white');
                    circle.setAttribute('stroke', '#333');
                    circle.setAttribute('stroke-width', '1.5');
                } else {
                    // Black dot (ratio 1:2)
                    circle.setAttribute('fill', '#333');
                    circle.setAttribute('stroke', '#333');
                    circle.setAttribute('stroke-width', '1');
                }

                svg.appendChild(circle);
            }

            // Draw white dots (consecutive pairs)
            if (rule.white_dots) {
                rule.white_dots.forEach(pair => {
                    drawDot(pair, true);
                });
            }

            // Draw black dots (ratio pairs)
            if (rule.black_dots) {
                rule.black_dots.forEach(pair => {
                    drawDot(pair, false);
                });
            }
        }

        // Draw Arrow Sudoku arrows (transparent lines with arrowheads from circle to arrow cells)
        function drawArrows() {
            const rule = metadata.rule;
            if (!rule.arrows) return;

            const svg = document.getElementById('diagonalOverlay');
            const table = document.getElementById('sudokuGrid');

            // Get table dimensions
            const tableRect = table.getBoundingClientRect();
            const containerRect = table.parentElement.getBoundingClientRect();

            // Set SVG dimensions to match table
            svg.setAttribute('width', tableRect.width);
            svg.setAttribute('height', tableRect.height);
            svg.style.width = tableRect.width + 'px';
            svg.style.height = tableRect.height + 'px';
            svg.style.left = (tableRect.left - containerRect.left) + 'px';
            svg.style.top = (tableRect.top - containerRect.top) + 'px';

            const cellSize = 50; // Cell size from CSS
            const borderWidth = 3; // Table border width

            // Color palette for arrows
            const arrowColors = [
                '#e57373', // red
                '#64b5f6', // blue
                '#81c784', // green
                '#ffb74d', // orange
                '#ba68c8', // purple
                '#4dd0e1', // cyan
                '#f06292', // pink
                '#aed581', // light green
                '#7986cb', // indigo
                '#ff8a65', // deep orange
                '#4db6ac', // teal
                '#dce775'  // lime
            ];

            // Create defs for arrowhead markers if not exists
            let defs = svg.querySelector('defs');
            if (!defs) {
                defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                svg.appendChild(defs);
            }

            // Draw each arrow with a different color
            rule.arrows.forEach((arrow, index) => {
                const arrowColor = arrowColors[index % arrowColors.length];
                const markerId = 'arrowhead-' + index;

                // Create arrowhead marker for this color if not exists
                if (!defs.querySelector('#' + markerId)) {
                    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                    marker.setAttribute('id', markerId);
                    marker.setAttribute('markerWidth', '6');
                    marker.setAttribute('markerHeight', '4');
                    marker.setAttribute('refX', '5');
                    marker.setAttribute('refY', '2');
                    marker.setAttribute('orient', 'auto');
                    marker.setAttribute('markerUnits', 'strokeWidth');

                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polygon.setAttribute('points', '0 0, 6 2, 0 4');
                    polygon.setAttribute('fill', arrowColor);
                    polygon.setAttribute('fill-opacity', '0.8');

                    marker.appendChild(polygon);
                    defs.appendChild(marker);
                }

                const [circleRow, circleCol] = arrow.circle;
                const circleCenter = getCellCenter(circleRow, circleCol, cellSize, borderWidth);

                // Create a path from the last arrow cell to the circle (reversed direction)
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                // Build path data starting from the last arrow cell and ending at circle
                const arrowCells = arrow.arrow_cells;
                if (arrowCells.length === 0) return;

                // Start from the last arrow cell
                const [lastRow, lastCol] = arrowCells[arrowCells.length - 1];
                const lastCenter = getCellCenter(lastRow, lastCol, cellSize, borderWidth);
                let pathData = `M ${lastCenter.x} ${lastCenter.y}`;

                // Go through arrow cells in reverse order (excluding the last one we started from)
                for (let i = arrowCells.length - 2; i >= 0; i--) {
                    const [row, col] = arrowCells[i];
                    const center = getCellCenter(row, col, cellSize, borderWidth);
                    pathData += ` L ${center.x} ${center.y}`;
                }

                // End at the circle cell
                pathData += ` L ${circleCenter.x} ${circleCenter.y}`;

                path.setAttribute('d', pathData);
                path.setAttribute('stroke', arrowColor);
                path.setAttribute('stroke-width', '3');
                path.setAttribute('stroke-opacity', '0.8');
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');
                path.setAttribute('marker-end', `url(#${markerId})`);

                svg.appendChild(path);
            });
        }

        // Draw Killer Sudoku cages with proper dashed borders and sum labels
        function drawKillerCages() {
            const rule = metadata.rule;
            if (!rule.cages) return;

            const svg = document.getElementById('diagonalOverlay');
            const table = document.getElementById('sudokuGrid');

            // Get table dimensions
            const tableRect = table.getBoundingClientRect();
            const containerRect = table.parentElement.getBoundingClientRect();

            // Set SVG dimensions to match table
            svg.setAttribute('width', tableRect.width);
            svg.setAttribute('height', tableRect.height);
            svg.style.width = tableRect.width + 'px';
            svg.style.height = tableRect.height + 'px';
            svg.style.left = (tableRect.left - containerRect.left) + 'px';
            svg.style.top = (tableRect.top - containerRect.top) + 'px';

            const cellSize = 50; // Cell size from CSS
            const borderWidth = 3; // Table border width
            const inset = 3; // Inset from cell edge for dashed border

            // Helper to get cell top-left corner coordinates
            function getCellTopLeft(row, col) {
                let x = borderWidth + col * cellSize;
                let y = borderWidth + row * cellSize;

                // Add thicker borders after columns 3 and 6
                if (col >= 3) x += 1;
                if (col >= 6) x += 1;

                // Add thicker borders after rows 3 and 6
                if (row >= 3) y += 1;
                if (row >= 6) y += 1;

                return { x, y };
            }

            // Draw each cage
            rule.cages.forEach((cage, index) => {
                const cells = cage.cells;
                const cageSet = new Set(cells.map(([r, c]) => `${r},${c}`));

                // Build the cage outline path by finding edges
                // An edge should be drawn if the adjacent cell is NOT in the same cage
                let pathData = '';

                cells.forEach(([row, col]) => {
                    const topLeft = getCellTopLeft(row, col);
                    const x = topLeft.x + inset;
                    const y = topLeft.y + inset;
                    const w = cellSize - 2 * inset;
                    const h = cellSize - 2 * inset;

                    // Check each edge
                    // Top edge: draw if cell above is not in cage
                    if (!cageSet.has(`${row - 1},${col}`)) {
                        pathData += `M ${x} ${y} L ${x + w} ${y} `;
                    }
                    // Bottom edge: draw if cell below is not in cage
                    if (!cageSet.has(`${row + 1},${col}`)) {
                        pathData += `M ${x} ${y + h} L ${x + w} ${y + h} `;
                    }
                    // Left edge: draw if cell to left is not in cage
                    if (!cageSet.has(`${row},${col - 1}`)) {
                        pathData += `M ${x} ${y} L ${x} ${y + h} `;
                    }
                    // Right edge: draw if cell to right is not in cage
                    if (!cageSet.has(`${row},${col + 1}`)) {
                        pathData += `M ${x + w} ${y} L ${x + w} ${y + h} `;
                    }
                });

                // Create the path element for the cage outline
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathData);
                path.setAttribute('stroke', '#9c27b0');
                path.setAttribute('stroke-width', '1.5');
                path.setAttribute('stroke-dasharray', '4,3');
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke-linecap', 'round');
                svg.appendChild(path);

                // Find the top-left cell of the cage for the sum label
                let minRow = Number.MAX_SAFE_INTEGER, minCol = Number.MAX_SAFE_INTEGER;
                cells.forEach(([r, c]) => {
                    if (r < minRow || (r === minRow && c < minCol)) {
                        minRow = r;
                        minCol = c;
                    }
                });

                // Draw sum label in top-left corner of the top-left cell
                const labelTopLeft = getCellTopLeft(minRow, minCol);
                const labelX = labelTopLeft.x + 4;
                const labelY = labelTopLeft.y + 12;

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', labelX);
                text.setAttribute('y', labelY);
                text.setAttribute('font-size', '10');
                text.setAttribute('font-weight', 'normal');
                text.setAttribute('font-family', 'Arial, sans-serif');
                text.setAttribute('fill', '#9c27b0');
                text.textContent = cage.sum;
                svg.appendChild(text);
            });
        }

        // Draw Futoshiki inequality symbols (< > ‚à® ‚àß) between cells
        function drawFutoshikiInequalities() {
            const rule = metadata.rule;
            if (!rule.inequalities) return;

            const svg = document.getElementById('diagonalOverlay');
            const table = document.getElementById('sudokuGrid');

            // Get table dimensions
            const tableRect = table.getBoundingClientRect();
            const containerRect = table.parentElement.getBoundingClientRect();

            // Set SVG dimensions to match table
            svg.setAttribute('width', tableRect.width);
            svg.setAttribute('height', tableRect.height);
            svg.style.width = tableRect.width + 'px';
            svg.style.height = tableRect.height + 'px';
            svg.style.left = (tableRect.left - containerRect.left) + 'px';
            svg.style.top = (tableRect.top - containerRect.top) + 'px';

            const cellSize = 50; // Cell size from CSS
            const borderWidth = 3; // Table border width

            // Draw each inequality symbol
            rule.inequalities.forEach(inequality => {
                const [r1, c1] = inequality.cell1;
                const [r2, c2] = inequality.cell2;
                const operator = inequality.operator;

                const center1 = getCellCenter(r1, c1, cellSize, borderWidth);
                const center2 = getCellCenter(r2, c2, cellSize, borderWidth);

                // Calculate midpoint between the two cells
                const midX = (center1.x + center2.x) / 2;
                const midY = (center1.y + center2.y) / 2;

                // Determine if horizontal or vertical
                const isHorizontal = r1 === r2;

                // Create a group for the marker
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');

                // Create background circle for visibility
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', midX);
                circle.setAttribute('cy', midY);
                circle.setAttribute('r', 10);
                circle.setAttribute('fill', 'white');
                circle.setAttribute('stroke', '#9c27b0');
                circle.setAttribute('stroke-width', '1');
                g.appendChild(circle);

                // Determine the symbol to display
                let symbol;
                if (isHorizontal) {
                    // Horizontal: use < or >
                    symbol = operator === '<' ? '<' : '>';
                } else {
                    // Vertical: use ‚àß or ‚à®
                    // ‚àß points to the smaller value (cell1 < cell2 means cell1 is smaller)
                    // ‚à® points to the larger value (cell1 > cell2 means cell1 is larger)
                    symbol = operator === '<' ? '‚àß' : '‚à®';
                }

                // Create the text symbol
                const textEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                textEl.setAttribute('x', midX);
                textEl.setAttribute('y', midY);
                textEl.setAttribute('text-anchor', 'middle');
                textEl.setAttribute('dominant-baseline', 'central');
                textEl.setAttribute('font-size', '14');
                textEl.setAttribute('font-weight', 'bold');
                textEl.setAttribute('font-family', 'Arial, sans-serif');
                textEl.setAttribute('fill', '#9c27b0');
                textEl.textContent = symbol;
                g.appendChild(textEl);

                svg.appendChild(g);
            });
        }

        // Only allow numbers 1-9
        document.querySelectorAll('.sudoku input').forEach(input => {
            input.addEventListener('input', function(e) {
                const value = e.target.value;
                const row = parseInt(e.target.dataset.row);
                const col = parseInt(e.target.dataset.col);
                const key = `${row},${col}`;

                if (notesMode) {
                    // Notes mode: toggle number in notes (add if not present, remove if present)
                    if (value && /^[1-9]$/.test(value)) {
                        if (!cellNotes[key]) {
                            cellNotes[key] = new Set();
                        }
                        
                        if (cellNotes[key].has(value)) {
                            // Note already exists, remove it
                            recordAction({
                                type: 'note',
                                operation: 'remove',
                                row: row,
                                col: col,
                                value: value
                            });
                            cellNotes[key].delete(value);
                            if (cellNotes[key].size === 0) {
                                delete cellNotes[key];
                            }
                        } else {
                            // Note doesn't exist, add it
                            recordAction({
                                type: 'note',
                                operation: 'add',
                                row: row,
                                col: col,
                                value: value
                            });
                            cellNotes[key].add(value);
                        }
                        updateNotesDisplay(row, col);
                        e.target.value = ''; // Clear input after toggling note
                    } else {
                        e.target.value = '';
                    }
                } else {
                    // Normal mode: single number entry
                    if (value && (!/^[1-9]$/.test(value))) {
                        e.target.value = '';
                    } else if (value) {
                        // Record the old value before changing
                        const oldValue = e.target.getAttribute('data-old-value') || '';
                        recordAction({
                            type: 'number',
                            row: row,
                            col: col,
                            oldValue: oldValue,
                            newValue: value
                        });
                        // Store current value for next change
                        e.target.setAttribute('data-old-value', value);

                        // Clear notes when entering a number in normal mode
                        if (cellNotes[key]) {
                            delete cellNotes[key];
                            updateNotesDisplay(row, col);
                        }
                        highlightSameNumbersAndRowCol(e.target, value);
                    } else {
                        // Clearing the cell (backspace/delete)
                        const oldValue = e.target.getAttribute('data-old-value') || '';
                        if (oldValue) {
                            recordAction({
                                type: 'number',
                                row: row,
                                col: col,
                                oldValue: oldValue,
                                newValue: ''
                            });
                            e.target.setAttribute('data-old-value', '');
                        }
                        highlightSameNumbersAndRowCol(e.target, value);
                    }
                }
            });

            input.addEventListener('focus', function(e) {
                const row = parseInt(e.target.dataset.row);
                const col = parseInt(e.target.dataset.col);
                
                // If hint mode is active, apply hint to this cell
                if (hintMode) {
                    applyHint(row, col);
                    return;
                }
                
                const value = e.target.value;
                highlightSameNumbersAndRowCol(e.target, value);
            });

            input.addEventListener('blur', function(e) {
                clearHighlights();
            });

            // Add keyboard navigation
            input.addEventListener('keydown', function(e) {
                // Allow spacebar to toggle notes mode even in input fields
                if (e.code === 'Space') {
                    e.preventDefault();
                    toggleNotesMode();
                    return;
                }

                // Handle Delete/Backspace in notes mode
                if (notesMode && (e.key === 'Delete' || e.key === 'Backspace')) {
                    e.preventDefault();
                    const row = parseInt(e.target.dataset.row);
                    const col = parseInt(e.target.dataset.col);
                    const key = `${row},${col}`;
                    // Clear all notes for this cell
                    if (cellNotes[key]) {
                        // Record action before clearing
                        recordAction({
                            type: 'note',
                            operation: 'clear',
                            row: row,
                            col: col,
                            oldNotes: Array.from(cellNotes[key])
                        });
                        delete cellNotes[key];
                        updateNotesDisplay(row, col);
                    }
                    return;
                }

                handleKeyboardNavigation(e, e.target);
            });
        });

        // Add click, focus, blur and keyboard navigation listeners to prefilled cells
        document.querySelectorAll('.sudoku td.prefilled').forEach(cell => {
            cell.addEventListener('click', function(e) {
                cell.focus();
                const value = e.target.textContent.trim();
                highlightSameNumbersAndRowCol(cell, value);
            });

            cell.addEventListener('focus', function(e) {
                const value = e.target.textContent.trim();
                highlightSameNumbersAndRowCol(cell, value);
            });

            cell.addEventListener('blur', function(e) {
                clearHighlights();
            });

            cell.addEventListener('keydown', function(e) {
                handleKeyboardNavigation(e, cell);
            });
        });

        // Unified keyboard navigation handler
        function handleKeyboardNavigation(e, element) {
            let row, col;
            if (element.tagName === 'INPUT') {
                row = parseInt(element.dataset.row);
                col = parseInt(element.dataset.col);
            } else {
                row = parseInt(element.getAttribute('data-row'));
                col = parseInt(element.getAttribute('data-col'));
            }

            let newRow = row;
            let newCol = col;

            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    newRow = row > 0 ? row - 1 : row;
                    break;
                case 'ArrowDown':
                case 'Enter':
                    e.preventDefault();
                    newRow = row < 8 ? row + 1 : row;
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    newCol = col > 0 ? col - 1 : col;
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    newCol = col < 8 ? col + 1 : col;
                    break;
                default:
                    return; // Don't navigate for other keys
            }

            if (newRow !== row || newCol !== col) {
                // Try to find input first, then prefilled cell
                let nextCell = document.querySelector(`input[data-row="${newRow}"][data-col="${newCol}"]`);
                if (nextCell) {
                    nextCell.focus();
                    nextCell.select();
                } else {
                    nextCell = document.querySelector(`td[data-row="${newRow}"][data-col="${newCol}"].prefilled`);
                    if (nextCell) {
                        nextCell.focus();
                    }
                }
            }
        }

        // Clear highlights when clicking outside the sudoku grid
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.sudoku')) {
                clearHighlights();
            }
        });

        function checkSolution() {
            let allCorrect = true;
            let allFilled = true;
            const inputs = document.querySelectorAll('.sudoku input');

            inputs.forEach(input => {
                const row = parseInt(input.dataset.row);
                const col = parseInt(input.dataset.col);
                const value = input.value;
                const cell = input.parentElement;

                // Remove previous styling
                cell.classList.remove('correct', 'incorrect');

                if (!value) {
                    allFilled = false;
                    return;
                }

                if (parseInt(value) === solution[row][col]) {
                    cell.classList.add('correct');
                } else {
                    cell.classList.add('incorrect');
                    allCorrect = false;
                }
            });

            const messageDiv = document.getElementById('message');
            if (!allFilled) {
                messageDiv.innerHTML = '<span class="error">Please fill in all cells first!</span>';
            } else if (allCorrect) {
                messageDiv.innerHTML = '<span class="success">üéâ Congratulations! You solved the Sudoku correctly! üéâ</span>';
            } else {
                messageDiv.innerHTML = '<span class="error">Some cells are incorrect. Keep trying!</span>';
            }
        }

        function clearAll() {
            document.querySelectorAll('.sudoku input').forEach(input => {
                input.value = '';
                input.removeAttribute('data-old-value');
                input.parentElement.classList.remove('correct', 'incorrect', 'hint-cell');
                const row = parseInt(input.dataset.row);
                const col = parseInt(input.dataset.col);
                const key = `${row},${col}`;
                if (cellNotes[key]) {
                    delete cellNotes[key];
                    updateNotesDisplay(row, col);
                }
            });
            document.getElementById('message').innerHTML = '';
        }

        function resetBoard() {
            clearAll();
            // Clear undo history on reset
            undoHistory.length = 0;
            // Reset hints
            hintsRemaining = 3;
            hintMode = false;
            const hintBtn = document.getElementById('hintBtn');
            hintBtn.classList.remove('active');
            updateHintButtonDisplay();
        }

        // Function to update the notes display for a cell
        function updateNotesDisplay(row, col) {
            const key = `${row},${col}`;
            const notesDiv = document.querySelector(`.notes[data-row="${row}"][data-col="${col}"]`);
            if (notesDiv) {
                if (cellNotes[key] && cellNotes[key].size > 0) {
                    // Sort and display notes
                    const sortedNotes = Array.from(cellNotes[key]).sort().join(' ');
                    notesDiv.textContent = sortedNotes;
                } else {
                    notesDiv.textContent = '';
                }
            }
        }

        function generateNewPuzzle() {
            const messageDiv = document.getElementById('generation-message');
            const doorNumber = {{ door }};

            // Disable button and show loading message
            const button = event.target;
            button.disabled = true;
            button.textContent = 'Generating...';
            messageDiv.innerHTML = '<span style="color: #2196F3;">Generating new puzzle... This may take a moment.</span>';

            // Call the Flask route to generate a new puzzle
            fetch(`/generate/${doorNumber}`)
                .then(response => {
                    // Check if response is JSON
                    const contentType = response.headers.get('content-type');
                    if (!contentType || !contentType.includes('application/json')) {
                        throw new Error('Server returned non-JSON response. This may be a permissions issue on the server.');
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        messageDiv.innerHTML = '<span style="color: #4CAF50;">‚úì ' + data.message + ' Reloading...</span>';
                        // Reload the page after a short delay to show the new puzzle
                        setTimeout(() => {
                            window.location.reload();
                        }, 1000);
                    } else {
                        messageDiv.innerHTML = '<span style="color: #f44336;">‚úó ' + data.message + '</span>';
                        button.disabled = false;
                        button.textContent = 'Generate New Puzzle';
                    }
                })
                .catch(error => {
                    console.error('Generation error:', error);
                    messageDiv.innerHTML = '<span style="color: #f44336;">‚úó Error: ' + error.message + '</span>';
                    button.disabled = false;
                    button.textContent = 'Generate New Puzzle';
                });
        }

        function highlightSameNumbersAndRowCol(selectedCell, number) {
            clearHighlights();
            if (!selectedCell) return;

            // Get row and col
            let row = null, col = null;
            if (selectedCell.tagName === 'INPUT') {
                row = parseInt(selectedCell.dataset.row);
                col = parseInt(selectedCell.dataset.col);
            } else {
                row = parseInt(selectedCell.getAttribute('data-row'));
                col = parseInt(selectedCell.getAttribute('data-col'));
            }

            // Highlight row and column (only if enabled)
            if (highlightRowColEnabled) {
                document.querySelectorAll('.sudoku td').forEach(cell => {
                    const cellRow = parseInt(cell.getAttribute('data-row'));
                    const cellCol = parseInt(cell.getAttribute('data-col'));
                    if (cellRow === row || cellCol === col) {
                        cell.classList.add('rowcol-highlight');
                    }
                });
            }

            // Highlight selected cell
            if (selectedCell.tagName === 'INPUT') {
                selectedCell.parentElement.classList.add('selected-cell');
            } else {
                selectedCell.classList.add('selected-cell');
            }

            // Highlight all cells with the same number (only if enabled)
            if (highlightSameNumberEnabled && number) {
                document.querySelectorAll('.sudoku td').forEach(cell => {
                    const text = cell.textContent.trim();
                    const input = cell.querySelector('input');
                    if (text === number && cell.classList.contains('prefilled')) {
                        cell.classList.add('highlighted-prefilled');
                    } else if (input && input.value === number && input.value !== '' && !cell.classList.contains('prefilled')) {
                        cell.classList.add('highlighted-user');
                    }
                });
            }
        }

        function clearHighlights() {
            document.querySelectorAll('.sudoku td').forEach(cell => {
                cell.classList.remove('highlighted', 'highlighted-prefilled', 'highlighted-user', 'rowcol-highlight', 'selected-cell');
            });
        }
        
        function toggleLanguageMenu() {
            const dropdown = document.getElementById('languageDropdown');
            dropdown.classList.toggle('active');
        }
        
        function changeLanguage(lang) {
            fetch('/set_language/' + lang)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        location.reload();
                    }
                });
        }
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const dropdown = document.getElementById('languageDropdown');
            if (!dropdown.contains(event.target)) {
                dropdown.classList.remove('active');
            }
        });
    </script>
</body>
</html>
